# 内存管理

以cpp在win中为例，在一个项目仓库中，有多个.cpp文件和.dll文件，如main.cpp、func.cpp和usb.dll  
在使用g++编译时，大体分为编译->链接两步  
首先将main.cpp和func.cpp编译为main.o、func.o  
此时有main.o、func.o、usb.dll  
然后进行链接，将main.o、func.o链接为main.exe，main.exe中有一处指向usb.dll  
此时有main.exe、usb.dll  
现在这个新程序的逻辑地址就确定下来了，地址由main.exe开始，中间到usb.dll转了一个弯，最后又回到main.exe  

## 逻辑地址和物理地址
程序执行时，需要有一个统一的标准，因此每个进程都有一个自己的内存空间，这个在前两章也提过。这个内存空间的地址从0开始，但是现实中内存有很多个进程在同时运行，不可能每个进程的地址都是在真实的内存地址0中开始，且逻辑地址是连续的，内存中不可能每个进程都分配连续的地址  
因此引出了逻辑地址和物理地址(内存真实地址)

## 内存连续分配管理方式：
有3大类
- 单一连续分配：用在单道程序系统
- 固定分区分配：把内存分成固定大小的分区，每个分区装一个进程
- 动态分区分配：根据进程所需大小，动态分配内存空间

### 动态分区分配
又分4种方法
- 首次适应算法：按地址顺序找到第一个能满足大小的空闲分区就直接分配
- 邻近适应算法：在首次适应的基础上，从上次查找结束的位置继续查找
- 最佳适应算法：在整个分区中找能满足大小的最小空闲分区;会产生最多的外部碎片
- 最坏适应算法：在整个分区中找能满足大小的最大空闲分区

内部碎片：在固定分区分配中，os给进程A分配64kB空间，那么A的内存空间有64kB，但A只用50kB，没用的14kB被称为内部碎片

外部碎片：总空间有64kB，os给各进程总共分配50kB，但是剩下的14kB并不连续，可能分成很多块夹在进程的空间之间，这些碎片就称为外部碎片

为了避免碎片的产生，所以引入了分页

## 基本分页储存管理
我们对逻辑地址和物理地址同时进行分页  
比如说总空间有64kB，而进程A需要16kB的空间，那么我们按照4kB一个页，把总空间片成16份，把A空间片成4份；那么A空间的4份中的每一份，大小都和总空间中的每一份一致；于是乎我们可以把这4份随便装进总空间的16份中的随便4份  
这样在逻辑地址中，这4份是连续的；在物理地址中，这4份不是连续的。那么我们增加一个叫页表的东西，将逻辑地址和物理地址对应 

| 逻辑页号 | 物理块号 |
|----------|----------|
| 0        | 7        |
| 1        | 4        |
| 2        | 13       |
| 3        | 2        |

此时CPU在处理时，使用逻辑地址，然后通过页号查询物理地址来进行访存  

>页表是每个进程自己维护一份，存放于PCB中  
>页内偏移量：页号只是记载了这个页在整个16kB空间中的起始地址，那么我们只需要一个页内偏移量，就能知道某个确切逻辑地址  

类比：
```
页号 ＋ 页内偏移量 ＝ 确切逻辑地址
2    ＋  0.516     ＝ 2.516
```

且我们知道，一个页和一个物理块对应，且大小相同  
那么我们查询上述页表，将对应物理块号和页内偏移量相加，就能得到确切物理地址  
查询上表可知页号2位于物理块号13中
```
块号 ＋ 页内偏移量 ＝ 确切物理地址
13   ＋  0.516     ＝ 13.516
```
某分页存储管理的逻辑地址结构如下

|            | 页号范围 | 页内偏移量范围 |
|------------|----------|----------------|
|二进制位数  | 31 … 12  | 11 … 0         |


页内偏移量0到11有12位，即$2^{12}$，我们知道页内偏移量的取值是从页的起始到页的结束，那么页内偏移量的二进制位数就表示了页面的大小  
即页面大小＝$2^{12}$->4kB  
而页号12到31则代表页的个数  
页表项：一条页号和物理块号的对应记录就是一条页表项  
> 32位物理地址空间：地址线宽度为32位，每一位可以访出1和0两种状态，因此可以寻址$2^{32}$ b的空间，也就是4GB


## 二级页表
为什么要有二级页表？  
有32位逻辑地址，需要寻址4GB，假设页表项大小4B，页面大小4kB＝$2^{12}$ b；那么共有$2^{32}$/$2^{12}$＝$2^{20}$个页面，每个页面有一个页号，也有一个对应的物理块号，因此有页表项$2^{20}$条，那么页表项大小为$2^{20}$*4＝$2^{22}$ b＝4MB，需要占据连续的$2^{22}$/$2^{12}$＝$2^{10}$＝1024个页面。需要的存储空间不大，但是仅页表却要求连续的1k个页面；如果是64位逻辑地址，仅页表的存储空间就要求16PB的连续存储空间，因此现代64位系统都是使用多级页表来提高存储效率

 
在之前，逻辑地址划分为两部分，分别是页号和页内偏移量；我们保持页内偏移量不动，对页号进一步划分为页表号和页号  

页表号中存储页表的位置  
页号则就是页表项中的页号  

| 页表号       | 页号         | 页内偏移量   |
|--------------|--------------|--------------|
| 0001001000   | 1101000101   | 011001111000 |

那么就有$2^{10}$个页表，通过页表号0001001000查找到具体页表A，再通过页号1101000101在页表A中找到物理块号X，此时X加上页内偏移量就是具体物理地址X011001111000

## 快表(TLB)
在采用多级页表的系统中，要得到物理地址就需要先由最外级页表号到内存中找到第二级页表号，再由2级找3级，依次类推。那么获得一次物理地址就需要多次访存，效率极低  
因此引出快表: 有一高速缓存器TLB，系统寻找物理地址时先到TLB中寻找，如果有，就称为命中；如果没有，就到内存中的页表找，找到后，再将结果放入TLB；如果TLB已满，则按特定算法淘汰掉TLB的其中一条旧页表项

## 页表的维护
局部性原理：进程运行时，有很多数据都是暂时用不到的，大多数时候，进程都只关注最常用的一些数据，而这些数据被分片的页面，才会长期留在内存中，其他的数据都是需要时才调入内存

缺页：当进程需要某些数据，却在内存中留存的页面中找不到时，就称为缺页

缺页中断：一旦发生缺页，就会进行缺页中断，将缺失的页面调进内存

驻留集大小：os告诉进程，你最多可以放x个页面在内存中，x就是驻留集大小

抖动：如果驻留集太小，那么进程就会频繁缺页，进行缺页中断来调入页面，占用太多CPU，这种现象就叫抖动

工作集：某段时间内，进程访问的页面集合，由时间t和工作集大小确定  
工作集反映了进程接下来一段时间内可能会频繁访问的页面

### 内存分配策略

分配的数量是否可变

- 固定分配：进程驻留集大小确定后不可变
- 可变分配：进程驻留集大小根据情况改变

### 内存置换策略

缺页时从哪置换

- 局部置换：进程A有5页面，缺页时只在这5页面中置换
- 全局置换：进程A有5页面，进程B有6页面，进程A缺页置换时可以从进程B的6页面中置换

分配和置换策略两两配合，但固定和全局不可配合，以全局可变为反例说明

| 进程       | A  | B  | C  |
|------------|----|----|----|
| 驻留集大小 | 5  | 5  | 5  |
| A缺页后    | 6  | 4  | 5  |

A页面数＋1，B－1，如果是固定就没法这么做

### 页面置换算法

有4种

- 最佳置换(OPT): 存在于幻想中，没有实现
- 先进先出页面置换(FIFO)：淘汰最早进入内存的页面，会出现Belady异常  
    Belady异常：在增加页面数时，缺页次数反而增加
- 最近最久未使用置换：淘汰最近最长时间未使用的页面

模拟：
```
访问序列为0 1 2 7 0 5 3 5 0 2 7 6  
分配4个页框  
首先将前4位写入页框(如果有重复就多写入)  
看第5位0，命中 此时0127  
第6位5，未命中，从第6位往前4位，淘汰1，此时0527  
第7位3，未命中，从7往前4，淘汰2，此时0537  
第8位5，命中，此时0537  
第9位0，命中，此时0537  
第10位2，未命中，发现7是在列表中最早的且近期未访问，淘汰7，此时0532  
第11位7，未命中，淘汰3，此时0572  
第12位6，未命中，淘汰5，此时0672  
```
- 时钟(CLOCK)置换
    - 类CLOCK：给每个页设置访问位＝1，当置换时，从上一次置换页的下一位开始，循环遍历页队伍；遇访问位＝1，则将其置0；遇访问位＝0，则淘汰。
    - 改进CLOCK：给每个页设置(访问位A＝1，修改位M＝1)

    模拟改进CLOCK：
    ```
    此时有4类  
    A＝0，M＝0  
    A＝0，M＝1  
    A＝1，M＝0  
    A＝1，M＝1

    执行四轮检查:
    第一轮：将第一个A＝0，M＝0的淘汰, 没有找到的话执行第二轮
    第二轮：将第二个A＝0，M＝1的淘汰，同时将扫描过的页面的A都置0, 没有找到的话执行第三轮
    第三轮：重复第一步
    第四轮：重复第二步,此时一定能找到被淘汰的页
    ```

