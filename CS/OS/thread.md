# 进程与线程

## 进程、线程、协程与异步(async)

```example
有这么一个餐厅(操作系统), 来了几个客人(用户), 点了几道菜(需求), 这个餐厅有3个厨房(进程), 分别煮出客人想吃的菜, 其中一个厨房内有若干个厨师(线程)。有一个厨师他先打开电饭煲煮了些米饭, 但是煮饭需要时间, 煮好了会发出声音通知厨师(异步任务)；因此这个厨师就先去忙自己的事情, 他开始炒一盘菜, 他先翻炒(协程1), 火候差不多的时候下盐(协程2), 再翻炒几下(协程1), 尝了尝味道(协程3), 发现盐不太够(需要协程2), 于是他又放了点盐(协程2), 最后装盘(协程4), 这时电饭煲发出声音提醒他米饭煮好了(异步任务完成)
```

- 程序: 是存放在硬盘内的一个二进制可执行文件
- 进程: 是程序的一次执行过程。由PCB、程序段、数据段三部分构成
- PCB: 是进程创建时同时创建的, 放在内存中的内核空间, 是进程存在的唯一标志
  - 进程标识符(PID)
  - 程序计数器PC
  - 寄存器内容
  - 进程状态
  - 优先级
  - 程序和数据区域指针

### 进程的通信

主要有三种方法

- 共享存储: 一个进程向共享的内存区域写入数据, 共享这个内存区域的所有进程就都可以立刻看到其中内容
- 消息传递: 又分两种
  - 直接通信: 发送进程直接将消息发送给接收进程, 并挂在消息缓冲队列上
  - 间接通信: 发送进行把消息发给中间实体(信箱)中, 接收方从中间实体取得
- 管道通信: 半双工通信, 单个管道某一段时间只能单向传输数据。且管道必须写满才能读, 必须读空才能写

## 线程

>进程: 进程是资源分配的基本单位且能独立调度  
>线程: 进程是调度的基本单位, 线程共享进程的资源与内存空间  
>操作系统分配资源和内存空间给进程, 而进程共享资源和内存空间给线程, 并调度线程来完成任务

### 为什么引入线程

线程的创建、撤销、调度、切换不需要操作系统插手, 也就不需要频繁切换用户-内核态, 不需要频繁分配/回收资源, 因此能更好提高系统效率

### 线程的实现方式

- `用户级线程` 所有线程管理均由应用程序完成, 操作系统内核意识不到线程的存在, 不需要用户态-内核态切换, 轻量级  
用户级线程本身是进程分配到的CPU资源在并发运行, 因此只要有一个线程进入阻塞, 整个进程都会被阻塞
- `内核级线程`
由操作系统在内核空间创建, 作为一种资源分配给进程, 除了开销大没有缺点

## CPU调度

调度算法  
3个基础算法


- FCFS先来先服务
- SJF短作业优先  
  饥饿现象: 如果一直有短作业进入就绪队伍, 长作业就会一直阻塞
- 高响应比优先
  响应比Rp＝(等待时间＋占用CPU时间)/占用CPU时间

4个进阶算法

- 优先级调度算法  
  - 非抢占式优先级: 优先级高的在就绪队伍中插-队, 但不立刻把当前使用CPU的进程赶下去  
  - 抢占式优先级: 同上, 但是赶下去  
  - 静态优先级: 创建进程时就确定优先级  
  - 动态优先级: 创建给一个, 随时间变化
- RR时间片轮转  
  每隔一段时间就换人。如果时间太长, 就退化成先来先服务；时间太短, 进程就切换频繁, CPU开销大
- 多级队列  
  设计多个就绪队列, 队列内部的进程优先级可以不同
- 多级反馈队列  
  设计多个就绪队列  
  第一个队列优先级最高, 然后依次降低  
  队伍优先级越高, 时间片越小, 每个队列采用先来先服务, 只有前面的队列空闲才会执行后面的队列  
  新进程先进入第一队列, 进程在第一个队列中分配到CPU, 如果在时间片内没有执行完, 就进入第二队列, 依次类推, 直到最后进入末队列, 在末队列, 采用时间片轮转  
  如果CPU为在低优先级队列的进程服务时, 有高优先级队列中进入线程, 则立刻将当前进程放回低优先级队列的末尾, 执行高优先级进程

## 临界区互斥
有4原则

- 空闲让进: 没人用就让进
- 忙则等待: 有人用就在外面等
- 有限等待: 外面不能一直等
- 让权等待: 进不了就别占CPU

软件实现方法有4种

- `单标志法`(违背空闲让进)  
  设置公用变量`turn`, 值为允许进入临界区的进程编号  
  进程必须交替进入临界区, 如果有一进程x不进入临界区, 但`turn`值又为x, 就会造成临界区空闲, 但没有人进入的情况  
- `双标志先检查法`(违背忙则等待)  
  设置bool型数组flag[x], flag[x]=true表示进程x想进入临界区  
  初始均为false, 当两个进程同时想进入临界区时, 检查对方的flag均为false, 然后又同时设置自己的flag为true, 这时就会同时进入临界区  
- `双标志后检查法`(违背空闲让进、有限等待)  
  同样flag, 先设置flag＝true, 然后再检查对方的flag  
  如果有两个进程同时有进入临界区的意向, 他们都设置flag＝true, 然后检查对方, 发现都是true, 于是就卡这了, 违背空闲让进和有限等待  
- `Peterson算法`(没有遵循让权等待)  
  既有flag也有`turn`  
  两个进程通过flag表明意向, 然后抢着给`turn`赋值, `turn`可能同时被赋值x和y, 但其中一个马上就会被另一个覆盖掉。`turn`最终决定谁进入临界区  

硬件方法有3种

- `中断屏蔽`
  关中断, 执行完临界区任务会再打开  
- `TestAndSet`(无让权等待)  
  设置了公用bool变量lock, 类似于双标志法的实现, 但相比于双标志法, TS指令用硬件方法(原子操作)将检查与上锁一气呵成  
- `Swap`(无让权) 类TS


### 互斥锁
互斥锁是操作系统提供的方法, 而并非算法或者硬件操作  
互斥锁有`acquire`和`release`两个函数, 两个函数的执行都是原子操作  
- 自旋等待: 某进程`acquire`时, 发现临界区有进程在使用, 就会不断尝试`acquire`直到获取锁, 这样占用CPU资源高
- 阻塞等待: 某进程`acquire`时, 发现临界区有进程在使用, 就会被操作系统挂到阻塞队列, 直到临界区进程`release`时, 操作系统会唤醒它

### 信号量 PV
信号量值 `S.value` , 可以表示资源`S`的数量  
阻塞队列 `S.L ` 
- `P`(wait())操作:请求资源
  ```
  令S.value－1, 进程获得资源
  如果S.value＜0, 说明资源分配完毕, 进程进入阻塞态, 进入阻塞队列S.L
  ```
- `V`(single())操作:释放资源
  ```
  令S.value＋1, 进程释放资源
  如果S.value≤0, 表示仍有进程在等待, 于是用wakeup唤醒S.L中的第一个进程
  ```

> P、V、wakeup均为原子操作  

### 管程

一种语言提供的库函数/语言特性  
每次仅允许一个进程进入管程  

- 饥饿: 进程长期得不到想要的资源
- 死循环: 一直跳不出某个循环
- 死锁: 各进程互相等待对方手里的资源

4个死锁条件

- 互斥
- 不可剥夺
- 循环等待

