### 线性表

#### 分类
- **顺序存储**：利用一组地址连续的存储单元。
- **链式存储**：储存单元地址并不连续，每个链表节点中都包含`data`，以及指向下一个`Node`的`ptr`。

#### 特点
- **顺序表**：
  - 即数组，数组可以根据给定的`index`直接获取`data`，称为随机访问，如`Array[Index]`。
  - 但是插入数据不方便，需要将插入位后的所有`data`集体后移。

- **链表**：
  - 因为链表中并不知各节点位置，下一个节点位置仅存在于上节点处，因此无法进行随机访问。
  - 但是插入`data`操作非常简单，只需修改插入位前后两节点的指针即可做到。

### 链表类型
- **单链表**：
  - 尾节点的`ptr`指向`NULL`；有一`ptr`指向头节点，称为`headptr`，被用户持有，用户通过`headptr`访问整个链表。

- **双链表**：
  - 较单链表增加了前驱指针；其他方法与单链表类似，仅有插入和删除不同。

- **循环单链表**：
  - 将尾节点的后继指针指向头节点，形成一个“环”；有时对循环单链表不设头指针，仅设尾指针，原因是尾指针指向尾节点，可以直接进行尾插操作，而尾节点的下一节点即为头节点，也可直接进行头插操作。

- **循环双链表**：
  - 头节点的前驱指针指向尾节点。

- **静态链表**：
  - 一块地址连续的内存空间，但是数据在其中并不是连续存放的。
  - 数组形态，但是数组中存放的是节点，每个节点包含`data`和`index`。

### 栈
- **概念**：
  - 首先栈与传统意义上的栈堆并没有直接关系，栈在数据结构中仅是一种线性表，使用栈与入栈入堆并没有直接联系，栈只是模拟栈堆中的栈形成的一种数据结构。
  - 堆栈：栈是程序运行中内存中一组连续的空间，由系统直接管理，程序中的变量会直接入栈；堆是程序运行中内存中一组不连续的空间，由用户管理，在无GC的语言中需要手动管理，在C中用`malloc`即为向系统申请一块内存空间（堆）来存放数据。

- **为什么说栈比堆快？**
  - 因为栈是一组连续的空间，且因为是变量，使用率高，所以更容易被Cache命中。

#### 类型
- **顺序栈**：
  - 利用一组地址连续的存储单元。
  - 栈结构体中含元素数组，栈顶游标。

- **共享栈**：
  - 共享一个一维数组空间。
  - 如`Array[50]`，第一个栈栈底索引为0，第二个栈栈底为50，两栈的栈顶向中间延伸。
  - 两栈栈顶指针相邻(`top1 - top2 = 1`)视为栈满。

- **链栈**：
  - 非连续，链式的。
  - 与链表类似，数据与指针捆绑。

### 队列
- **概念**：
  - 操作受限的线性表。
  - 队列是一种结构体，内涵数据数组，队头指针和队尾指针。

#### 类型
- **顺序队列**：
  - 连续的存储单元。
  - 由`rear`位进，`front`位出。
  - 依图可以看出，都出队后，`rear`位置无法进入更多的元素，但实际上是有充足空间进行存放的，容易存在一种假溢出。

- **循环队列**：
  - 用于解决假溢出问题。
  - 循环队列`rear`和`front`的取值用取余`%`完成。
  - 设队列最大长度为`maxsize`。
  - 当出队列`rear = (rear + 1) % maxsize`。
  - 当进队列`front = (front + 1) % maxsize`。

- **获取队列长度**：
  - `long = (rear + maxsize - front) % maxsize`。

- **如何判队空or队满？**
  - 1. **牺牲一个存储单元**：约定“`front`在`rear`的下一位置”作为队满的标志。
    - 那么队满时`rear`指向的存储单元就会为空，且无法使用。
    - `(rear + 1) % maxsize = front`。
  - 2. **记录个数**：结构体中新增变量`size`，当`size = maxsize`时，队满。
  - 3. **标志位**：结构体中新增变量`tag`，出队置0，入队置1。
    - `rear = front`时，若`tag = 0`，队空；若`tag = 1`，队满。

- **链式队列**：
  - 操作受限的单链表。

- **双端队列**：
  - 两端都可以进行插入和删除的线性表。

### 栈的应用
- **中缀表达式转后缀表达式**：
  - 中缀表达式：`3 + 4`
  - 后缀表达式：`3 4 +`
  - 在转换中，有栈和输出两变量，输出为最终结果，栈辅助计算。
  - 运算符优先级：
    1. 括号`()`
    2. 乘除法`*/`
    3. 加减法`+ -`
    - 同级运算符：左到右计算。
  - 栈中存放运算符来辅助计算。
  - 示例：`9 + (3 - 1) * 3 + 10 / 2`
    - 遇9，不是运算符，入输出。
      - 输出：`9`
      - 栈：空
    - 遇`+`入栈。
      - 输出：`9`
      - 栈：`+`
    - 遇`(`入栈,遇3入输出,遇`-`入栈,遇1入输出。
      - 输出：`9 3 1`
      - 栈：`+(-`
    - 遇`)`，开始出栈到输出，直至`(`。
      - 输出：`9 3 1 -`
      - 栈：`+`
    - 遇`*`入栈，遇3入输出。
      - 输出：`9 3 1 - 3`
      - 栈：`+*`
    - 遇`+`，应入栈，但是栈顶元素的优先级高于`+`，因此先弹出，弹出`*`后发现栈中仍有`+`与新的`+`优先级相同，故而再弹出旧`+`，入新`+`。
      - 输出：`9 3 1 - 3 * +`
      - 栈：`+`
    - 遇10入输出，遇`/`入栈，遇2入输出。
      - 输出：`9 3 1 - 3 * + 10 2`
      - 栈：`+/`
    - 依次弹出栈。
      - 输出：`9 3 1 - 3 * + 10 2 / +`

- **计算后缀表达式**：
  - 式：`9 3 1 - 3 * + 10 2 / +`
  - 思路：栈仍为辅助计算，遇操作数入栈；遇运算符，弹出栈顶两个操作数运算，结果压回栈。
  - 遇9 3 1入栈。
    - 栈：`9 3 1`
  - 遇`-`，弹出1和3，3 - 1 = 2，2入栈。
    - 栈：`9 2`
  - 遇3入栈。
    - 栈：`9 2 3`
  - 遇`*`，弹出3和2，2 * 3 = 6，6入栈。
    - 栈：`9 6`
  - 遇`+`，弹出6和9，9 + 6 = 15，15入栈。
    - 栈：`15`
  - 遇10 2，入栈。
    - 栈：`15 10 2`
  - 遇`/`，弹出2和10，10 / 2 = 5，5入栈。
    - 栈：`15 5`
  - 遇`+`，弹出5和15，15 + 5 = 20。
    - 最终得20。

### 数组
- **概念**：
  - 一维数组可视为线性表，二维数组可视为元素是定长数组的线性表。
  - 数组一旦被定义，维数和维界不再改变。
- **映射方法**：
  - 按行优先
  - 按列优先

### 特殊矩阵的压缩
- **对称矩阵**：
  - 中上三角和下三角对应元素相同，浪费一半空间，可将其压缩为一维数组`B`存放。
  - 矩阵中有索引`i`和`j`，`B`中有索引`index`。
  - 若`i`与`j`从1起始，上三角区在`B`中对应索引的计算公式为：
    - `i(i + 1)/2 + j`
  - 下三角公式只需交换`i`与`j`的位置。
  - 如果`i`与`j`从0起始，则按上述公式计算完毕后+1。

---

