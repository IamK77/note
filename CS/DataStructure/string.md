### 串
- **定长顺序存储**: 地址连续的存储单元。结构体中含数据数组和串长。
- **堆分配**: 仍是地址连续, 动态分配堆空间, 堆的单次分配的内存块是连续的。结构体中含堆空间指针和串长。

### 简单模式匹配
逐个匹配

### KMP
#### 观察以下简单模式匹配的流程瞬间
```
              ↓
a b a b c a b c a b a a b    主串    
    a b c a b a              子串     
              ↑
0 1 2 3 4 5 6 7 8 9          index
```

不难发现在索引`2-3`处和索引`5-6`处, 子串的部分都是`ab`, 那么为什么要按简单模式匹配一步步的慢慢匹配, 子串完全可以`5-2`直接进行下一次匹配

#### KMP算法原理
由此延伸了KMP算法: 已匹配相等的前缀序列中有某个后缀正好是模式中的前缀, 则可将模式串向后滑动到与这些相等字符对齐的位置, 主串i指针无须回溯, 并从该位置开始继续比较

- **前缀序列**: 索引 `2-6`
- **某个后缀**: 索引 `5-6`
- **模式中的前缀**: 索引 `2-3`

#### 按KMP匹配的结果如下
```
              ↓
a b a b c a b c a b a a b       主串
          a b c a b a           子串 
              ↑
0 1 2 3 4 5 6 7 8 9            index
```

**注意**: 主串指针在主串中的索引不变, 而子串位置从末尾 `a` 移动到 `c`。

#### 如何知道子串指针应移动多少位？
**计算子串的部分匹配值 (PM)**: 取子串部分的前缀和后缀的最长公共长度。

| index | 前缀 | 后缀 |    解释     | PM |
|-------|------|------|-------------|----|
| 1     | a    | 无   |  a无前无后  | 0  |
| 2     | ab   | 无   |  ab无前无后 | 0  |
| 3     | abc  | 无   |             | 0  |
| 4     | abca | a    |前缀的a和后缀的a| 1  |
| 5     | abcab| ab   | 前ab 后ab   | 2  |
| 6     | abcaba| a   |  前a 后a    | 1  |

因此, PM: `000121`

- `子串移动位数 = 已匹配子串位数 - PM 上一位`
- 在上述流程瞬间, 子串指针指向`尾a`, 而前5位均已匹配, 因此, 已匹配子串位数为`5`; `尾a`对应的PM为 `00012*1*`, 上一位为`2`, 因此, PM上一位为`2` \
`子串移动位数 = 5 - 2 = 3`  \
因此, 子串指针由`尾a`往前移动`3`位, 指向`c`


#### next数组(-1 起始)
将 PM 向右移一位, 末位舍弃, 首位补 `-1`, 即为 next 数组。

- PM `0 0 0 1 2 1` → `-1 0 0 0 1 2`
- `指针向前位数 = 已匹配位数 - next 值`

| next | -1 | 0 | 0 | 0 | 1 | 2 |
|------|----|---|---|---|---|---|
| 指针向前位数 | 1  | 1 | 2 | 3 | 3 | 3 |
```
0-(-1)=1
1-0=1
2-0=2
3-0=3
4-1=3
5-2=3
```

#### next数组(0 起始)
在上一步基础上全 `+1`。

- next `-1 0 0 0 1 2` → `0 1 1 1 2 3`

| next | 0 | 1 | 1 | 1 | 2 | 3 |
|------|----|---|---|---|---|---|
| 指针应指向位数 | 1 | 1 | 1 | 1 | 2 | 3 |


**在-1起始的 next 数组中**: 
- `0` 表示将子串指针移向开头; 
- `-1` 表示子主指针均向后 1 位。

**在 0 起始的 next 数组中**: 
- `0` 表示子主指针均向后 1 位; 
- 其余数字 `x` 表示匹配失败时, 将子串指针移到子串第 `x` 位。

### 内存中逐步模拟 KMP 匹配过程

```
↓
a b a b c a b c a b a a b   主
a b c a b a                 子
↑
```
```
  ↓
a b a b c a b c a b a a b   主
a b c a b a                 子
  ↑
```
```
    ↓
a b a b c a b c a b a a b   主
a b c a b a                 子
    ↑
```
匹配失败, 查询next数组 0 1 1 1 2 3
移动至 子串第1位
```
    ↓
a b a b c a b c a b a a b   主
a b c a b a                 子
↑
```
```
      ↓
a b a b c a b c a b a a b   主
a b c a b a                 子
  ↑
```
```
        ↓
a b a b c a b c a b a a b   主
a b c a b a                 子
    ↑
```
```
          ↓
a b a b c a b c a b a a b   主
a b c a b a                 子
      ↑
```
```
            ↓
a b a b c a b c a b a a b   主
a b c a b a                 子
        ↑
```
```
              ↓
a b a b c a b c a b a a b   主
a b c a b a                 子
          ↑
```
匹配失败, 查询 0 1 1 1 2 3
移动到子串第 3 位
```
              ↓
a b a b c a b c a b a a b   主
a b c a b a                 子
    ↑
```
```
                ↓
a b a b c a b c a b a a b   主
a b c a b a                 子
      ↑
后续两步只需子主指针各自向后两位即可匹配成功, 不再演示
```



### KMP 的进一步优化
例: 
```
a a a b a a a a b   主 
a a a a b           子
子串 next 为: 0 1 2 3 4
      ↓
a a a b a a a a b   主
a a a a b           子
      ↑
```

发现匹配失败, 查询 `0 1 2 3 4`. 子串指针移动至子串第 `3` 位。
```
          ↓
主: a a a b a a a a b
子: a a a a b
        ↑
```
但会发现, 子串指向的又是`a`, 而查阅`0 1 2 3 4`, 会发现, 子串指针下次以及下下次指向的又又是`a`, 但主串指针会一直保持`b`不变, 这就令这几次运算毫无意义,这就引出了**nextval**, 是**next**的进一步改良 \
在**next**的基础上: 

| 子串  | a | a | a | a | b |
|-------|---|---|---|---|---|
| next  | 0 | 1 | 2 | 3 | 4 |
| nextval | 0 | 0 | 0 | 0 | 4 |

发现next[3]指向`a a *a* a b`, 而这一位所代表的next[2]指向`a *a* a a b`, 又是a, 其代表的next[1]指向`*a* a a a b`, 又是`a`, 其代表的next[0]指向`0`, 因此之前递归的所有next值均为`0`   \
因此nextval: `0 0 0 0 4`

观察可发现, 子串指向的多次是 `a`, 主串指针保持在 `b`, 故次次运算无效。这引出 , 在 next 的基础上进行优化: 



